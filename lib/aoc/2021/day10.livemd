<!-- vim: syntax=markdown -->

# AoC Day10

## Setup

```elixir
Mix.install([
  {:kino, "~> 0.4"}
])
```

```elixir
input = Kino.Input.textarea("Please input:")
```

```elixir
input =
  Kino.Input.read(input)
  |> String.split("\n", trim: true)
```

## Section

```elixir
defmodule SyntaxChecker do
  @scores %{
    ?) => {?(, 1, 3},
    ?] => {?[, 2, 57},
    ?} => {?{, 3, 1197},
    ?> => {?<, 4, 25137}
  }

  def score(code, stack \\ [])

  def score(<<char, code::binary>>, stack) when char in [?<, ?{, ?[, ?(],
    do: score(code, [char | stack])

  def score(<<char, code::binary>>, [current_open | stack]) when char in [?>, ?}, ?], ?)] do
    case @scores do
      %{^char => {^current_open, _, _}} ->
        score(code, stack)

      %{^char => {_, _, corrupted_score}} ->
        {:corrupted, corrupted_score}
    end
  end

  def score("", stack) do
    completing_score =
      Enum.reduce(stack, 0, fn char, score ->
        {_, {_, completing_score, _}} = Enum.find(@scores, &match?({_, {^char, _, _}}, &1))
        score * 5 + completing_score
      end)

    {:incomplete, completing_score}
  end
end
```

## Part 1

```elixir
input
|> Stream.map(&SyntaxChecker.score/1)
|> Stream.filter(&match?({:corrupted, _}, &1))
|> Stream.map(fn {_, score} -> score end)
|> Enum.sum()
```

## Part 2

```elixir
scores =
  input
  |> Stream.map(&SyntaxChecker.score/1)
  |> Stream.filter(&match?({:incomplete, _}, &1))
  |> Stream.map(fn {_, score} -> score end)
  |> Enum.sort()

center = div(length(scores), 2)
Enum.at(scores, center)
```
